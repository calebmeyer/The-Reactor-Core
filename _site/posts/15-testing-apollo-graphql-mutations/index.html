<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>The Reactor Core</title>
        <style media="screen">
            /* note: not actually a sass file, just using that for syntax highlighting */

/*
 * main green: #d3fc05
 */

body {
    background: #101010;
    color: #c8d1b8;
    font-family: gitan-latin; Tahoma, Verdana, sans-serif;
    font-size: 20px;
    line-height: 1.6;
    padding: 50px;
}

/* light color scheme: https://coolors.co/d3fc05-2b303a-f6f7eb-3abecf-7c7c7c */
body.light {
    background: #f6f7eb;
    color: #2B303A;
}

/* Thanks llogiq for the style inspiration! */
.wrapper {
    width: 860px;
    margin: 0 auto;
}

@media print, screen and (max-width: 960px) {
    div.wrapper {
        width: auto;
        margin: 0;
    }
}

@media print, screen and (max-width: 720px) {
    body {
        word-wrap: break-word;
    }

    pre, code {
        word-wrap: normal;
    }
}

@media print, screen and (max-width: 480px) {
    body {
        padding: 15px;
    }

    h1 {
        font-size: 20pt;
    }

    h2 {
        font-size: 16pt;
    }

    h3 {
        font-size: 14pt;
    }
}

@media print {
    body {
        padding: 0.4in;
        font-size: 12pt;
        color: #444;
    }
}

a {
    transition: text-shadow 0.5s;
    color: #d6f1fc;
}

body.light a {
    color: #3abecf;
}

a:hover {
    text-shadow: 0 0 10px #a9cc66;
}

body.light a:hover {
    text-shadow: 0 0 10px #3abecf;
}

pre {
    background: #1D1F21;
    border: 1px solid #5C5C5C;
    border-radius: 5px;
}
code {
    background: #1D1F21;
    color: #0088FF;
    font-family: "Source Code Pro", monospace;
}
blockquote {
    background: #1D1F21;
    border-left: 3px solid #d3fc05;
}

body.light pre {
    background: #f6f7eb;
    color: #2B303A;
}

body.light blockquote {
    background: #f6f7eb;
    color: #2B303A;
    border-left: 3px solid #95f3ff;
}

body.light code {
    background: #f6f7eb;
    color: #3abecf;
}
body.light code.hljs {
    background: #1d1f21;
    color: #b6ced8;
}

blockquote > p {
    padding-bottom: 0.5em;
}
table {
    margin: 1em auto;
    border-collapse: collapse;
}
table, th, td {
    border: 1px solid #5C5C5C;
}
tr:hover {
    background: #1D1F21;
}
th {
    background: #1D1F21;
}
body.light tr:hover, body.light th {
    background: #f6f7eb;
}

small {
    /* slightly faded and dimmed version of the body text color */
    color: #a4a5a2;
}

body.light small {
    color: #404752;
}

header a, h1, h2, h3, h4, h5, h6 {
    font-family: Tahoma, Verdana, sans-serif;
}

.site-title-wrapper {
    width: 400px;
    display: inline-block;
}
.site-title {
    margin: 0;
}
.site-title a, .glow {
    color: #d3fc05;
    text-decoration: none;
    animation-name: radiate;
    animation-duration: 5s;
    animation-timing-function: ease-out;
    animation-iteration-count: infinite;
}

body.light .site-title a, body.light .glow {
    color: #3abecf;
    animation-name: radiate-light;
}

@keyframes radiate {
    0% { text-shadow: 0 0 2px #a9cc66; }
    50% { text-shadow: 0 0 30px #a9cc66; color: #f0fc05; }
    100% { text-shadow: 0 0 2px #a9cc66; }
}

@keyframes radiate-light {
    0% { text-shadow: 0 0 2px #95f3ff; }
    50% { text-shadow: 0 0 30px #95f3ff; }
    100% { text-shadow: 0 0 2px #95f3ff; }
}

.nav {
    margin: 10px 0;
    display: inline-block;
    vertical-align: top;
    cursor: pointer;
}

.nav a {
    color: #d3fc05;
    text-decoration: none;
}

body.light .nav a {
    color: #3abecf;
}

.post .content h1 {
    color: #d3fc05;
}
.post .content h2 {
    color: #d3fc05;
}
.post .content h3 {
    color: #d3fc05;
}
.post .content h4 {
    color: #d3fc05;
}
.post .content h5 {
    color: #d3fc05;
}
.post .content h6 {
    color: #d3fc05;
}
.post .title {
    color: #d3fc05;
    margin-bottom: 0;
}
.post .content a:hover {
    color: #d3fc05;
}
.social-link:hover {
    color: #d3fc05;
}
.nav-item-title:hover {
    color: #d3fc05;
}
.tag a:hover {
    color: #d3fc05;
}
.post-preview .title a {
    color: #d3fc05;
}
.content-item a:hover {
    text-decoration: underline;
    color: #d3fc05;
}
.post-list .title {
    color: #d3fc05;
}

.tombstone {
    color: #d3fc05;
}

body.light .post .content h1 {
    color: #3abecf;
}
body.light .post .content h2 {
    color: #3abecf;
}
body.light .post .content h3 {
    color: #3abecf;
}
body.light .post .content h4 {
    color: #3abecf;
}
body.light .post .content h5 {
    color: #3abecf;
}
body.light .post .content h6 {
    color: #3abecf;
}
body.light .post .title {
    color: #3abecf;
    margin-bottom: 0;
}
body.light .post .content a:hover {
    color: #3abecf;
}
body.light .social-link:hover {
    color: #3abecf;
}
body.light .nav-item-title:hover {
    color: #3abecf;
}
body.light .tag a:hover {
    color: #3abecf;
}
body.light .post-preview .title a {
    color: #3abecf;
}
body.light .content-item a:hover {
    text-decoration: underline;
    color: #3abecf;
}
body.light .post-list .title {
    color: #3abecf;
}

body.light .tombstone {
    color: #3abecf;
}

.inline {
    display: inline;
}

blockquote > p {
    margin-left: 10px;
}

.language-shell .hljs-meta {
    user-select: none; /* don't allow users to select $ in shell */
}

img:not([width]) { /* set images to take up the full width, unless I specify a width on them */
    width: 100%;
}

kbd {
    background-color: #444;
    color: #c8d1b8;
    padding: 4px 10px;
    border-radius: 4px;
    border: 3px solid #aaa;
}

.follow-up {
    background-color: #242424;
    color: #d2f495;
    padding: 0.5em;
}

            .hljs-comment,
.hljs-quote
{
  color: #456b7c; /* darker version of background */
}

.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion
{
  color: #5dcdfd; /* faded light blue */
}

.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link,
.hljs-subst
{
  color: #35ddff; /* bright aqua */
}

.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition
{
  color: #13CE00; /* verdant green */
}

.hljs-title,
.hljs-section,
.hljs-attribute
{
  color: #96FF00; /* yellow green */
}

.hljs-keyword,
.hljs-selector-tag
{
  color: #1ea8fc; /* cerulean */
}

.hljs
{
  display: block;
  overflow-x: auto;
  background: #19272d;
  color: #b6ced8;
  padding: 0.5em;
  font-family: "Source Code Pro", "Consolas", monospace;
}

.hljs-emphasis
{
  font-style: italic;
}

.hljs-strong
{
  font-weight: bold;
}

        </style>

        <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap">
        <link rel="stylesheet" href="https://use.typekit.net/uvh1qwh.css">

        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
    </head>
    <body class="dark">
        <div class="wrapper">
            <header>
                <div class="site-title-wrapper">
                    <h1 class="site-title">
                        <a href="/">The Reactor Core</a>
                    </h1>
                    <small>Where the engineers hang out</small>
                </div>
                <h2 class="nav">
                    <a href="/about">About</a>
                </h2>
            </header>
            <hr>
            <main>
                <div class="post">
    <h1 class="title">15 - Testing Apollo GraphQL Mutations</h1>
    <small>Published 2023-11-29</small>
    <section class="content">
        <p>Recently, I've started working with Apollo's GraphQL implementation for JavaScript. One pattern that you'll sometimes see in GraphQL land is to pass in some callbacks for a mutation's lifecycle:</p>
<pre><code class="language-javascript">import { gql, useMutation } from &quot;@apollo/client&quot;;

const mutationText = gql`
  mutation AddToShoppingList {
    item
  }
`;
const callbacks = {
  onError: (error) =&gt; {
    console.error(error);
    throw error;
  },
  onComplete: () =&gt; {
    updateShoppingList();
  },
};

const [addToList, { loading }] = useMutation(mutationText, callbacks);
</code></pre>
<h2>Testing with Jest</h2>
<p>Over on the testing side, it's very easy to validate some of this. For example, if you want to test that useMutation was called with the correct text and callbacks, you can do something like this:</p>
<pre><code class="language-javascript">it(&quot;calls useMutation with the correct mutation and callbacks&quot;, () =&gt; {
  expect(useMutation).toHaveBeenCalledWith(mutationText, {
    onError: expect.any(Function),
    onComplete: expect.any(Function),
  });
});
</code></pre>
<p>But it stumped me for a long while how I could test that onError was called, or that onComplete was called. Today, I figured it out thanks to some clever hacks to test redux.</p>
<p>If you do an <code>import *</code> in your test file, you can <code>jest.spyOn</code> its functions. If you change <code>useMutation</code> to be spied upon, you can add your own mock implementation. That mock implementation can call your callbacks. In action, it looks like this:</p>
<pre><code class="language-javascript">import * as apolloClient from '@apollo/client';

describe('File under test', () =&gt; {
    let addMock;

    beforeEach(() =&gt; {
        addMock = jest.fn();

        jest.spyOn(apolloClient, 'useMutation').mockImplementation((mutation, callbacks) =&gt; {
            if (callbacks.onError) {
                try {
                    // call the real onError handler for coverage
                    callbacks.onError(new Error());
                }
            }

            if (callbacks.onComplete) {
                // call the real onComplete handler for coverage
                callbacks.onComplete();
            }

            // it's important that we return what the useMutation call is expecting
            return [addMock, { loading: true }];
        });
    });

    // actual tests go here
});
</code></pre>
<h2>Sidestepping the issue entirely with promises</h2>
<p>Thanks to my excellent coworker Michael Poole, I found out that there is a better way. Instead of passing in callbacks, you can use promises! <code>useMutation</code>'s returned mutation function is a promise. So you can call it like this:</p>
<pre><code class="language-javascript">const [addToList] = useMutation(mutationText);
const onError = (error) =&gt; {
  console.error(error);
  throw error;
};

addToList(variables).then(updateShoppingList).catch(onError);
</code></pre>
<p>And that means you can test it with a mock resolve/reject:</p>
<pre><code class="language-javascript">import { useMutation } from &quot;@apollo/client&quot;;

jest.mock(&quot;@apollo/client&quot;);

describe(&quot;when the mutation succeeds&quot;, () =&gt; {
  let addMock;
  beforeEach(() =&gt; {
    // arrange
    // or mockRejectedValue if the call should fail
    addMock = jest.fn().mockResolvedValue(&quot;blah&quot;);
    useMutation.mockImplementation(() =&gt; [addMock]);

    // act
  });

  // assert
});
</code></pre>

        <span class="tombstone">&#9670;</span>
    </section>
</div>

            </main>
            <footer>
                <!-- TODO: Add some content to my footer -->
            </footer>
        </div>
    </body>
</html>
